"""
Shared State for Starknet Intelligence Colony
==============================================
Thread-safe shared memory for inter-agent communication.
Uses asyncio primitives for concurrent access.
"""

import asyncio
import json
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, TypeVar, Generic
from dataclasses import dataclass, field, asdict
from enum import Enum
import logging
import aiofiles
from contextlib import asynccontextmanager

logger = logging.getLogger(__name__)


class MessageType(Enum):
    """Types of messages between agents"""
    PRICE_UPDATE = "price_update"
    ARBITRAGE_ALERT = "arbitrage_alert"
    TVL_UPDATE = "tvl_update"
    WHALE_MOVEMENT = "whale_movement"
    RESEARCH_COMPLETE = "research_complete"
    CONTENT_GENERATED = "content_generated"
    ALERT = "alert"
    STATUS = "status"


@dataclass
class MarketData:
    """Market data snapshot"""
    timestamp: str
    prices: Dict[str, float] = field(default_factory=dict)
    volumes: Dict[str, float] = field(default_factory=dict)
    changes_24h: Dict[str, float] = field(default_factory=dict)
    
    def to_dict(self) -> dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: dict) -> "MarketData":
        return cls(**data)


@dataclass
class ArbitrageOpportunity:
    """Arbitrage opportunity detected"""
    token: str
    buy_dex: str
    sell_dex: str
    buy_price: float
    sell_price: float
    profit_percent: float
    volume_usd: float
    timestamp: str = field(default_factory=lambda: datetime.utcnow().isoformat())
    
    def to_dict(self) -> dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: dict) -> "ArbitrageOpportunity":
        return cls(**data)


@dataclass
class WhaleMovement:
    """Large transfer detected"""
    tx_hash: str
    from_address: str
    to_address: str
    token: str
    amount: float
    amount_usd: float
    is_large: bool = True
    timestamp: str = field(default_factory=lambda: datetime.utcnow().isoformat())
    direction: str = "unknown"  # "inflow", "outflow", "internal"
    
    def to_dict(self) -> dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: dict) -> "WhaleMovement":
        return cls(**data)


@dataclass
class ResearchReport:
    """Research report generated by Research Agent"""
    id: str
    topic: str
    title: str
    summary: str
    findings: List[str] = field(default_factory=list)
    risks: List[str] = field(default_factory=list)
    opportunities: List[str] = field(default_factory=list)
    sources: List[str] = field(default_factory=list)
    timestamp: str = field(default_factory=lambda: datetime.utcnow().isoformat())
    sentiment: str = "neutral"
    confidence: float = 0.5
    
    def to_dict(self) -> dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: dict) -> "ResearchReport":
        return cls(**data)


@dataclass
class ContentPiece:
    """Generated content piece"""
    id: str
    type: str  # "tweet", "article", "report", "thread"
    platform: str
    title: str
    content: str
    tags: List[str] = field(default_factory=list)
    timestamp: str = field(default_factory=lambda: datetime.utcnow().isoformat())
    
    def to_dict(self) -> dict:
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: dict) -> "ContentPiece":
        return cls(**data)


class SharedState:
    """
    Thread-safe shared state for inter-agent communication.
    
    Features:
    - Concurrent read/write access
    - Message queue for async notifications
    - Persistence to disk
    - TTL for stale data
    """
    
    def __init__(self, persist_path: Optional[Path] = None):
        self._lock = asyncio.Lock()
        self._message_queue: asyncio.Queue = asyncio.Queue()
        
        # Data stores
        self._market_data: Optional[MarketData] = None
        self._arbitrage_opportunities: List[ArbitrageOpportunity] = []
        self._whale_movements: List[WhaleMovement] = []
        self._research_reports: List[ResearchReport] = []
        self._content_pieces: List[ContentPiece] = []
        self._alerts: List[Dict] = []
        
        # Agent status
        self._agent_status: Dict[str, str] = {}
        
        # Persistence
        self._persist_path = persist_path
        self._last_persist = datetime.utcnow()
        
        # Metrics
        self._metrics: Dict[str, Any] = {
            "messages_processed": 0,
            "price_updates": 0,
            "arbitrage_found": 0,
            "whale_sightings": 0,
            "reports_generated": 0,
            "content_created": 0,
        }
    
    # =========================================================================
    # Market Data Methods
    # =========================================================================
    
    async def update_market_data(self, data: MarketData):
        """Update current market data"""
        async with self._lock:
            self._market_data = data
            self._metrics["price_updates"] += 1
        await self._queue_message(MessageType.PRICE_UPDATE.value, data.to_dict())
        logger.info(f"Market data updated: {len(data.prices)} tokens")
    
    async def get_market_data(self) -> Optional[MarketData]:
        """Get current market data"""
        async with self._lock:
            return self._market_data
    
    # =========================================================================
    # Arbitrage Methods
    # =========================================================================
    
    async def add_arbitrage(self, opportunity: ArbitrageOpportunity):
        """Add a detected arbitrage opportunity"""
        async with self._lock:
            # Keep only recent opportunities (last 100)
            self._arbitrage_opportunities.insert(0, opportunity)
            self._arbitrage_opportunities = self._arbitrage_opportunities[:100]
            self._metrics["arbitrage_found"] += 1
        
        await self._queue_message(
            MessageType.ARBITRAGE_ALERT.value, 
            opportunity.to_dict()
        )
        logger.info(f"Arbitrage found: {opportunity.token} @ {opportunity.profit_percent:.2f}%")
    
    async def get_arbitrage_opportunities(self, 
                                           min_profit: float = 0.5,
                                           limit: int = 20) -> List[ArbitrageOpportunity]:
        """Get arbitrage opportunities filtered by minimum profit"""
        async with self._lock:
            filtered = [a for a in self._arbitrage_opportunities 
                       if a.profit_percent >= min_profit]
            return filtered[:limit]
    
    # =========================================================================
    # Whale Movement Methods
    # =========================================================================
    
    async def add_whale_movement(self, movement: WhaleMovement):
        """Add a detected whale movement"""
        async with self._lock:
            self._whale_movements.insert(0, movement)
            # Keep only last 1000 movements
            self._whale_movements = self._whale_movements[:1000]
            self._metrics["whale_sightings"] += 1
        
        await self._queue_message(
            MessageType.WHALE_MOVEMENT.value,
            movement.to_dict()
        )
        logger.info(f"Whale movement: {movement.token} ${movement.amount_usd:,.0f}")
    
    async def get_whale_movements(self, 
                                   since_hours: int = 24,
                                   limit: int = 50) -> List[WhaleMovement]:
        """Get recent whale movements"""
        from datetime import timedelta
        cutoff = datetime.utcnow() - timedelta(hours=since_hours)
        
        async with self._lock:
            recent = [w for w in self._whale_movements 
                     if datetime.fromisoformat(w.timestamp) >= cutoff]
            return recent[:limit]
    
    # =========================================================================
    # Research Methods
    # =========================================================================
    
    async def add_research_report(self, report: ResearchReport):
        """Add a completed research report"""
        async with self._lock:
            self._research_reports.insert(0, report)
            # Keep only last 100 reports
            self._research_reports = self._research_reports[:100]
            self._metrics["reports_generated"] += 1
        
        await self._queue_message(
            MessageType.RESEARCH_COMPLETE.value,
            report.to_dict()
        )
        logger.info(f"Research report: {report.title}")
    
    async def get_research_reports(self, 
                                    limit: int = 10) -> List[ResearchReport]:
        """Get recent research reports"""
        async with self._lock:
            return self._research_reports[:limit]
    
    async def get_latest_research(self, topic: str) -> Optional[ResearchReport]:
        """Get latest research report for a topic"""
        async with self._lock:
            for report in self._research_reports:
                if topic.lower() in report.topic.lower():
                    return report
            return None
    
    # =========================================================================
    # Content Methods
    # =========================================================================
    
    async def add_content(self, content: ContentPiece):
        """Add generated content"""
        async with self._lock:
            self._content_pieces.insert(0, content)
            # Keep only last 200 pieces
            self._content_pieces = self._content_pieces[:200]
            self._metrics["content_created"] += 1
        
        await self._queue_message(
            MessageType.CONTENT_GENERATED.value,
            content.to_dict()
        )
        logger.info(f"Content generated: {content.type} - {content.platform}")
    
    async def get_content(self, 
                          content_type: Optional[str] = None,
                          platform: Optional[str] = None,
                          limit: int = 20) -> List[ContentPiece]:
        """Get generated content, optionally filtered"""
        async with self._lock:
            content = self._content_pieces
            if content_type:
                content = [c for c in content if c.type == content_type]
            if platform:
                content = [c for c in content if c.platform == platform]
            return content[:limit]
    
    # =========================================================================
    # Alert Methods
    # =========================================================================
    
    async def add_alert(self, alert_type: str, message: str, severity: str = "info"):
        """Add an alert"""
        alert = {
            "type": alert_type,
            "message": message,
            "severity": severity,
            "timestamp": datetime.utcnow().isoformat()
        }
        async with self._lock:
            self._alerts.insert(0, alert)
            # Keep only last 100 alerts
            self._alerts = self._alerts[:100]
        
        await self._queue_message(MessageType.ALERT.value, alert)
        logger.info(f"Alert: [{severity}] {message}")
    
    async def get_alerts(self, 
                         severity: Optional[str] = None,
                         limit: int = 20) -> List[Dict]:
        """Get alerts, optionally filtered by severity"""
        async with self._lock:
            alerts = self._alerts
            if severity:
                alerts = [a for a in alerts if a["severity"] == severity]
            return alerts[:limit]
    
    # =========================================================================
    # Agent Status Methods
    # =========================================================================
    
    async def update_agent_status(self, agent_name: str, status: str):
        """Update an agent's status"""
        async with self._lock:
            self._agent_status[agent_name] = {
                "status": status,
                "timestamp": datetime.utcnow().isoformat()
            }
    
    async def get_agent_status(self) -> Dict[str, Dict]:
        """Get all agent statuses"""
        async with self._lock:
            return dict(self._agent_status)
    
    # =========================================================================
    # Metrics Methods
    # =========================================================================
    
    async def get_metrics(self) -> Dict[str, Any]:
        """Get colony metrics"""
        async with self._lock:
            return dict(self._metrics)
    
    async def increment_metric(self, key: str, amount: int = 1):
        """Increment a metric"""
        async with self._lock:
            if key in self._metrics:
                self._metrics[key] += amount
    
    # =========================================================================
    # Message Queue Methods
    # =========================================================================
    
    async def _queue_message(self, msg_type: str, data: Any):
        """Queue a message for other agents"""
        self._metrics["messages_processed"] += 1
        await self._message_queue.put({
            "type": msg_type,
            "data": data,
            "timestamp": datetime.utcnow().isoformat()
        })
    
    async def get_message(self) -> Optional[Dict]:
        """Get next message from queue (non-blocking)"""
        try:
            return self._message_queue.get_nowait()
        except asyncio.QueueEmpty:
            return None
    
    # =========================================================================
    # Persistence Methods
    # =========================================================================
    
    async def save_state(self, path: Optional[Path] = None):
        """Save current state to disk"""
        save_path = path or self._persist_path
        if not save_path:
            return
        
        async with self._lock:
            state = {
                "market_data": self._market_data.to_dict() if self._market_data else None,
                "arbitrage": [a.to_dict() for a in self._arbitrage_opportunities[:50]],
                "whales": [w.to_dict() for w in self._whale_movements[:100]],
                "research": [r.to_dict() for r in self._research_reports[:20]],
                "content": [c.to_dict() for c in self._content_pieces[:50]],
                "alerts": self._alerts[:50],
                "metrics": self._metrics,
                "saved_at": datetime.utcnow().isoformat()
            }
            
            try:
                async with aiofiles.open(save_path, 'w') as f:
                    await f.write(json.dumps(state, indent=2, default=str))
                self._last_persist = datetime.utcnow()
                logger.info(f"State saved to {save_path}")
            except Exception as e:
                logger.error(f"Failed to save state: {e}")
    
    async def load_state(self, path: Optional[Path] = None) -> bool:
        """Load state from disk"""
        load_path = path or self._persist_path
        if not load_path or not load_path.exists():
            return False
        
        try:
            async with aiofiles.open(load_path, 'r') as f:
                content = await f.read()
                state = json.loads(content)
            
            async with self._lock:
                if state.get("market_data"):
                    self._market_data = MarketData.from_dict(state["market_data"])
                self._arbitrage_opportunities = [
                    ArbitrageOpportunity.from_dict(a) for a in state.get("arbitrage", [])
                ]
                self._whale_movements = [
                    WhaleMovement.from_dict(w) for w in state.get("whales", [])
                ]
                self._research_reports = [
                    ResearchReport.from_dict(r) for r in state.get("research", [])
                ]
                self._content_pieces = [
                    ContentPiece.from_dict(c) for c in state.get("content", [])
                ]
                self._alerts = state.get("alerts", [])
                self._metrics = state.get("metrics", self._metrics)
            
            logger.info(f"State loaded from {load_path}")
            return True
        except Exception as e:
            logger.error(f"Failed to load state: {e}")
            return False
    
    # =========================================================================
    # Snapshot and Reset
    # =========================================================================
    
    async def get_snapshot(self) -> Dict[str, Any]:
        """Get full state snapshot"""
        async with self._lock:
            return {
                "market_data": self._market_data.to_dict() if self._market_data else None,
                "arbitrage_count": len(self._arbitrage_opportunities),
                "whale_count": len(self._whale_movements),
                "research_count": len(self._research_reports),
                "content_count": len(self._content_pieces),
                "alert_count": len(self._alerts),
                "metrics": self._metrics,
                "agents": self._agent_status,
                "timestamp": datetime.utcnow().isoformat()
            }
    
    async def clear_stale_data(self, max_age_hours: int = 24):
        """Clear stale data older than specified hours"""
        from datetime import timedelta
        cutoff = datetime.utcnow() - timedelta(hours=max_age_hours)
        
        async with self._lock:
            self._whale_movements = [
                w for w in self._whale_movements
                if datetime.fromisoformat(w.timestamp) >= cutoff
            ]
            self._alerts = [
                a for a in self._alerts
                if datetime.fromisoformat(a["timestamp"]) >= cutoff
            ]
        
        logger.info("Stale data cleared")


# Global shared state instance
shared_state = SharedState()
